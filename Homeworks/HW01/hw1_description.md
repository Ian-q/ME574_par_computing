# ME 574 Spring 2025 Homework 1

This assignment relates to dynamics of iterated maps, something that has become a classic problem and is presented in Chapter 1 of "Lessons in Scientific Computing". Schorghofer presents some sample results including a study of perhaps the most classic example involving the logistic map: 

$$x_{k+1} = f(x_k) = a x_k (1-x_k)$$

The basic idea of iterated mapping is to specify an initial value $x_0$ and the compute updated values by plugging the current value back into the mapping function:

$$\begin{aligned}
x_1 &= f(x_0) = a x_0 (1-x_0) \\
x_2 &= f(x_1) = a x_1 (1-x_1) \\ 
x_3 &= f(x_2) = a x_2 (1-x_2) \\
&
\vdots
\end{aligned}$$ 

Relevant questions involve finding fixed points (equilibria) and periodic points (which map back to themselves after multiple iterations), and determining their stability. (More sophisticated analysis involves determining the existence of non-periodic iteration histories or "trajectories", but that is beyond our current scope.)

The images in Schorghofer show the parabolic logistic function and some iteration histories/trajectories (plots of $x_k$ vs the iteration number $k$).

The goal of the following problems is to write python code to compute relevant data and produce some alternative visualizations of the behavior of the iterated logistic map.

1. In the template file (`hw1.py`), write code to complete the following functions: 
- `f(x,a)` that computes a value of the logistic map with input `x` and parameter `a` 
- `trajectory(f, x0, a, n)` that computes a `numpy` array of the first `n` iterates of the map `f` with initial value `x0` and parameter value `a`. 
The code in the function `p1()` tests your code to compute and plot iteration histories for $a \in \{0.9, 1.9, 2.9, 3.1, 3.5, 3.57 \}$ for specific values of $x_0$. 

After completing your implementation of `iterate`, you should execute the file (including the `p1` function) and look at the plots of the function and its iteration histories. 
- The first 2 plots show $y=f(x)$ and $y=x$ together. The intersection of these curves identifies an equilibrium value or fixed point. (What happens to the equilibrium value as $a$ increases?) 
- The next 2 plots show iteration trajectories corresponding to the values of $a$ in the first 2 plots. (You should see iterates approaching the equilibrium values.) 
- The remaining plots produced by `p1()` show iteration histories for larger values of $a$. With one exception, there is an initial transient behavior that dies out and gives rise to steady-state periodic behavior. Notice how the period doubles (from 1 iteration to 2 to 4 to 8...) as the value of the parameter $a$ changes. 

2. Now let's work on the alternate look at such behavior that is referred to as a "spiderweb diagram". The basic idea is to draw line segments vertically along the current iteration value to the plot of the function, then horizontally to the $45\degree$ line (i.e. $y = x$), then vertically to the function, then horizontally to $y=x$, etc.
- In the template file, fill in code to implement the function `spiderize(v)` that takes as input an iteration history (stored in a numpy array `v`) and returns a 2-tuple of arrays containing $x$-values and $y$-values for the spiderweb plot.
- After implementing `spiderize`, execute your python file including the function and look at the plots generated by the `p2()` function. Think about how they relate to the iteration histories from `p1()`.

3. In the template file, write code to implement the function `iterate(f,k,x)` that takes the following inputs:
- the name of the mapping function
- a numpy array of $x$ values, a float value for the parameter `a`
- an integer iteration count `k`

and returns a numpy array corresponding the the $k^{th}$ iterate of $f(x,a)$. 

Once your code for `iterate` is working, execute the file and look at the plots of your data produced by the `p3()` function.
Note the pattern of bifurcations associated with a fixed point (intersection with $y=x$) where at successively higher iterations the magnitude of the slope at the intersection passes through unity as the value of the parameeter $a$ changes.

If all goes well, this assignment should provide some python coding experience (associated with a problem that serves as an outstanding example of discovery via computation), and a basis for upcoming discussion of computations that are (or are not) well-suited for easy parallelization.